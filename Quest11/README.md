# Quest 11. RDB의 기초와 ORM

## Introduction

- 이번 퀘스트에서는 데이터베이스를 다루는 방법에 대해 알아보겠습니다.

## Topics

- RDBMS
- MySQL
- ORM
- Hash
  - scrypt

## Resources

- [MySQL 101 – The basics](https://www.globo.tech/learning-center/mysql-101-basics/)
- [Sequelize](https://sequelize.org/)
- [안전한 패스워드 저장](https://d2.naver.com/helloworld/318732)

## Checklist

- RDBMS 테이블의 정규화는 무엇인가요?
  > RDBMS이란 관계형 데이터베이스 관릿 시스템을 말한다.
  > RDBMS 테이블의 정규화란 무분별하게 table로 이루어진 data를 정리하고, 중복되는 속성 등을 제거하여 DB를 체계화하는 작업이라 할 수 있다.
  > 데이터모델링을 진행할 때 가장 중요한 요소에는 데이터 중복제거/단순화/일관성 확보 등이 있고, 정규화는 이러한 요소들을 보장하기 위해 진행하는 정제 작업이다.
- MySQL 외의 RDB에는 어떤 것들이 있나요?
  > PostgreSQL,MariaDB,Microsoft SQL server,Oracle Database
  - Relational Database 외에 다른 DB에는 어떤 것들이 있을까요?
    > nosql혹은 non relational이라고도 하며 비관계형 데이터베이스를 뜻한다. mongoDB,Redis,Dynamo등이 있다.
- RDBMS에서 테이블의 인덱싱은 무엇인가요? 인덱싱을 하면 어떤 점이 다르며, 어떤 식으로 동작하나요?

  > 테이블 인덱싱이란 테이블에 대한 동작의 속도를 높여주는 자료 구조를 말한다. -> 데이터베이스 내 자주 검색되는 내용에 색인을 남기는 것으로 색인을 통해서 검색의 범위를 줄여 검색의 효율을 높인다.
  >
  > 1.  인덱스 생성: 특정 열(column)을 기반으로 인덱스를 생성합니다. 이 때 인덱스를 구현하는 자료구조(B-Tree, Hash Map 등)를 선택합니다.
  > 2.  인덱스 유지보수: 새로운 레코드(record)가 추가되거나, 기존 레코드가 수정되거나 삭제되면 인덱스도 업데이트해야 합니다. 이 과정을 인덱스 유지보수(Index Maintenance)라고 합니다.
  > 3.  인덱스 검색: 인덱스를 사용하여 특정 레코드를 검색할 때는, 먼저 인덱스를 순회하여 해당 레코드가 저장된 블록(block)을 찾습니다. 이후 해당 블록에서 레코드를 검색하여 결과를 반환합니다.
  > 4.  인덱스 풀 스캔: 인덱스를 사용하지 않고 전체 테이블을 검색하는 것보다 빠른 경우도 있습니다. 이런 경우에는 인덱스 풀 스캔(Index Full Scan)을 사용하여 전체 인덱스를 순회하면서 레코드를 검색합니다. 인덱스 풀 스캔은 인덱스를 사용하지 않는 경우와 마찬가지로 모든 레코드를 검색해야 하기 때문에, 전체 테이블 스캔보다는 빠를 수 있지만, 인덱스 검색보다는 느릴 수 있습니다.
  > 5.  인덱스 통계 수집: 인덱스 통계(Index Statistics)는 인덱스의 성능을 개선하기 위해 사용됩니다. 인덱스 통계는 인덱스가 포함하는 값들의 분포를 파악하여, 검색 속도를 높이는 최적의 검색 계획을 수립할 수 있도록 합니다. 일반적으로 데이터베이스 시스템에서는 주기적으로 인덱스 통계를 수집하여 인덱스의 성능을 최적화합니다.

- ORM을 사용하는 것은 사용하지 않는 것에 비해 어떤 장단점을 가지고 있나요?
  > ORM:객체 관계 매핑, 객체와 데이터베이스의 관계를 매핑해주는 도구이다.
  > 사용하면 데이터를 받아오는 과정 자체는 데이터베이스 구성은 이해 필요할지라도 쿼리에 대한 이해가 없어도 가능하다. 데이터에 직접 접근하는 query에 비해 실행 및 처리속도가 느리고, query문을 대체하기엔 불리한 점이 많다.
  - 자바스크립트 생태계의 ORM에는 어떤 것들이 있나요?
    > sequelize가 있다. postgreSQL과 같은 관계형 데이터베이스와 많이 연동하여 사용한다.
- 모델간의 1:1, 1:N, N:M 관계는 각각 무엇이고 어떨 때 사용하나요?
  > 1:1 관계:서로 다른 요소가 정확히 하나의 요소만 연관이 되어있을 경우(ex/사람:주민등록번호)
  > 1:N 관계:한 요소가 다른 여러 요소와 연관이 되어 있을 경우(ex/사람:보유 카드)
  > N:M 관계:서로 여러 요소가 연관되어 있을 경우(ex/임원:직원)
- DB에 사용자의 암호를 평문으로 저장하지 않고도 사용자의 암호를 인증하는 것이 가능한 이유는 무엇일까요?
  > 암호화하는 알고리즘은 보통 정해져있고, 복호화 알고리즘도 암호화에 맞추어 제공되므로 알고리즘을 알고있다면 복호화를 통해 빠른 인증이 가능하다.
  - 해시 함수에는 어떤 것이 있나요?
    > Adaptive Key Derivation Functions, PBKDF2, bcrypt, scrypt 등이 있다.
  - 사용자의 암호를 해싱하여 저장할 때 어떤 식으로 저장하는 것이 보안에 좋을까요?
    > 단방향 해시 함수:어떤 수학적 연산/알고리즘에 의해 원본 데이터를 매핑시켜 완전히 다른 암호화된 데이터로 변환시키는 것. 변환을 해시, 암호화된 데이터를 다이제스트라고 한다.종류로는 SHA,MD 등이 있다. 하지만 동일한 문자열은 동일한 다이제스트가 나온다.
    > 솔트:해시 함수를 돌리기 전에 원문에 임의의 문자열을 덧붙이는 것으로 원문에 임의의 문자열을 붙인다는 의미의 소금친다는 것이다.
    > 솔트 과정까지 거친 다이제스트를 알아내더라도 더욱 알기 어려워진다.

## Quest

- 이번에는 메모장을 파일이 아닌 DB기반으로 만들어 보고자 합니다.
  - 적절한 테이블을 설계해 보세요.
  - Sequelize를 이용하여 데이터의 모델을 만들고 어플리케이션에 적용해 보세요.
  - 사용자의 비밀번호는 해싱을 통해 저장되어야 합니다.

## Advanced

- Object–relational impedance mismatch란 어떤 개념인가요?
- Foreign Key란 무엇인가요? 이것을 사용할 때의 장점과 단점은 무엇일까요?
- 이전에 쓰이던 해시함수들에는 어떤 것이 있을까요? 패스워드 해싱의 추세의 역사는 어떻게 이어져왔나요?
